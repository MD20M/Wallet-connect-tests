var Q = Object.defineProperty;
var V = (t, e, n) => e in t ? Q(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var l = (t, e, n) => (V(t, typeof e != "symbol" ? e + "" : e, n), n);
import { proxy as M, subscribe as G } from "valtio/vanilla";
import N from "bs58";
import { PublicKey as d, Transaction as Y, SystemProgram as _, TransactionInstruction as ee } from "@solana/web3.js";
import z from "bn.js";
import { sha256 as ne } from "@ethersproject/sha2";
import C from "borsh";
import te from "@walletconnect/qrcode-modal";
import se from "@walletconnect/universal-provider";
const p = M({
  connectors: [],
  chosenCluster: {
    name: "",
    id: "",
    endpoint: ""
  },
  walletConnectProjectId: "",
  requestId: 0,
  connectorName: ""
});
function B(t, e) {
  p[t] = e;
}
function D(t) {
  return p[t];
}
function q() {
  const t = p.requestId;
  return p.requestId = t + 1, p.requestId;
}
function w(t) {
  B("address", t);
}
function S() {
  return D("address");
}
function $(t) {
  const e = p.connectors.map((n) => n.getConnectorName());
  if (e.some((n) => n === t))
    B("connectorName", t);
  else
    throw new Error(`No connector with name ${t} exists,
     available options are: ${e.join(",")} `);
}
function U(t) {
  const { connectors: e } = p, n = e.find(
    (s) => s.getConnectorName() === t
  );
  if (!n)
    throw new Error("Invalid connector id configured");
  return n;
}
function oe() {
  const t = p.connectorName;
  return U(t);
}
function je(t) {
  return U(t).isAvailable();
}
function re(t) {
  B("chosenCluster", t);
}
function ae(t) {
  return console.log("Subscribing to cluster"), G(p, (n) => {
    const s = n.find((i) => i[1].includes("chosenCluster")), { id: o, name: r, endpoint: a } = p.chosenCluster;
    s && t({
      id: o,
      name: r,
      endpoint: a
    });
  });
}
function ce(t) {
  return console.log("Subscribing to address"), G(p, (n) => {
    n.find((o) => o[1].includes("address")) && t(p.address);
  });
}
function k() {
  return D("chosenCluster");
}
function ie(t) {
  B("walletConnectProjectId", t);
}
function J() {
  return D("walletConnectProjectId");
}
function ue(t) {
  Object.entries(t).forEach(([e, n]) => {
    B(e, n);
  }), $(t.connectorName);
}
function Ce(t, e) {
  e && ie(e), ue(t());
}
function Te(t) {
  $(t);
}
async function m(t) {
  const e = oe();
  return e.isAvailable() ? t(e) : null;
}
async function Ee() {
  return m(async (t) => t.connect());
}
async function Ie(t) {
  return m(async (e) => e.signMessage(t));
}
async function Me(t) {
  return m(async (e) => e.getAccount(t, "jsonParsed"));
}
async function De(t) {
  return m(async (e) => e.getBalance(t));
}
function qe() {
  return S();
}
function Fe(t) {
  return ce(t);
}
function xe(t) {
  re(t);
}
function Le() {
  return k();
}
function Oe(t) {
  return ae(t);
}
async function Re() {
  return m(async (t) => t.disconnect());
}
async function ze(t, e) {
  return m(async (n) => n.signTransaction(t, e));
}
async function He(t) {
  return m(async (e) => e.sendTransaction(t));
}
async function We(t) {
  return m(async (e) => e.getTransaction(t));
}
async function Ke(t, e) {
  return m(async (n) => n.signAndSendTransaction(t, e));
}
async function Ge(t, e) {
  return m(async (n) => n.watchTransaction(t, e));
}
async function $e(t, e) {
  return m(async (n) => n.getFeeForMessage(t, e));
}
async function Ue(t) {
  return m(async (e) => e.getSolDomainsFromPublicKey(t));
}
async function Je(t) {
  return m(async (e) => e.getFavoriteDomain(t));
}
async function Ze(t) {
  return m(async (e) => e.getAddressFromDomain(t));
}
const Xe = {
  name: "mainnetBeta",
  id: "4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
  endpoint: "https://solana-api.projectserum.com"
}, Qe = {
  name: "mainnetBeta",
  id: "4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
  endpoint: "https://api.mainnet-beta.solana.com"
};
function Ve() {
  return {
    name: "mainnetBeta",
    id: "4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
    endpoint: `https://rpc.walletconnect.com/v1?chainId=solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ&projectId=${J()}`
  };
}
const Ye = {
  name: "testnet",
  id: "8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
  endpoint: "https://api.testnet.solana.com"
}, _e = {
  name: "devnet",
  id: "8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
  endpoint: "https://api.devnet.solana.com"
}, en = {
  name: "mainnet",
  id: "4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
  endpoint: "https://try-rpc.mainnet.solana.blockdaemon.tech/"
}, de = "SPL Name Service", le = new d("85iDfUvr3HJyLM2zcq5BXSiDvUWfw6cSE1FfNBo8Ap29"), H = new d("58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx"), Z = new d("namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"), me = new d("33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z");
new d("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
new d("nftD3vbNkNqfj2Sd3HZwbpw4BxxKWr4AjGb9X38JeZk");
Buffer.from("tokenized_name");
async function fe(t) {
  return new Promise((e, n) => {
    let r = 0;
    const a = setInterval(() => {
      r > 10 - 1 ? (clearInterval(a), n(new Error("Maximum number of attempts exceeded"))) : t.readyState === t.OPEN && (clearInterval(a), e()), r += 1;
    }, 200);
  });
}
let h;
const F = M({}), E = M({});
async function ge() {
  const t = k(), { endpoint: e } = t;
  return h = new WebSocket(e.replace("http", "ws")), await fe(h), h.onmessage = (n) => {
    var o;
    const s = JSON.parse(n.data);
    s.id && (E[s.result] = s.id), (o = s.params) != null && o.subscription && (console.log("Found subscription", s.params.subscription), F[E[s.params.subscription]].callback(s.params.result));
  }, h;
}
function pe(t) {
  const { method: e } = F[t], n = Number(
    Object.entries(E).filter(([o, r]) => r === t)[0][0]
  ), s = e.replace("Subscribe", "Unsubscribe");
  if (!h)
    throw new Error("Socket not initalized");
  h.send(
    JSON.stringify({
      method: s,
      params: [n],
      jsonrpc: "2.0",
      id: q()
    })
  );
}
async function we(t, e, n) {
  h || await ge();
  const s = q();
  if (!h)
    throw new Error("Socket not initialized");
  return h.send(
    JSON.stringify({
      method: t,
      params: e,
      jsonrpc: "2.0",
      id: s
    })
  ), F[s] = { method: t, callback: n, id: s }, s;
}
function I(t) {
  const e = de + t, n = ne(Buffer.from(e, "utf8")).slice(2);
  return Buffer.from(n, "hex");
}
typeof window < "u" && (window.getHashedName = I);
async function W(t, e, n) {
  const s = [t];
  e ? s.push(e.toBuffer()) : s.push(Buffer.alloc(32)), n ? s.push(n.toBuffer()) : s.push(Buffer.alloc(32));
  const [o] = await d.findProgramAddress(s, Z);
  return o;
}
const L = class {
  constructor(e) {
    l(this, "tag");
    l(this, "nameAccount");
    this.tag = e.tag, this.nameAccount = new d(e.nameAccount);
  }
};
let A = L;
l(A, "schema", /* @__PURE__ */ new Map([
  [
    L,
    {
      kind: "struct",
      fields: [
        ["tag", "u8"],
        ["nameAccount", [32]]
      ]
    }
  ]
]));
const O = class {
  constructor(e) {
    l(this, "parentName");
    l(this, "owner");
    l(this, "class");
    l(this, "data");
    this.parentName = new d(e.parentName), this.owner = new d(e.owner), this.class = new d(e.class);
  }
};
let P = O;
l(P, "schema", /* @__PURE__ */ new Map([
  [
    O,
    {
      kind: "struct",
      fields: [
        ["parentName", [32]],
        ["owner", [32]],
        ["class", [32]]
      ]
    }
  ]
]));
class X {
  getConnectorName() {
    return "base";
  }
  async getProvider() {
    return Promise.reject(new Error("No provider in base connector"));
  }
  async constructTransaction(e, n) {
    const s = new Y(), o = S();
    if (!o)
      throw new Error("No address connected");
    const r = new d(o);
    if (e === "transfer") {
      const c = n, f = new d(c.to);
      s.add(
        _.transfer({
          fromPubkey: r,
          toPubkey: new d(c.to),
          lamports: c.amountInLamports
        })
      ), s.feePayer = c.feePayer === "from" ? r : f;
    } else if (e === "program") {
      const c = n;
      s.add(
        new ee({
          keys: [
            { pubkey: r, isSigner: !0, isWritable: c.isWritableSender }
          ],
          programId: new d(c.programId),
          data: Buffer.from(N.decode(JSON.stringify(c.data)))
        })
      ), s.feePayer = r;
    } else
      throw new Error(`No transaction configuration for type ${e}`);
    const a = await this.requestCluster("getLatestBlockhash", [{}]), { blockhash: i } = a.value;
    return s.recentBlockhash = i, s;
  }
  async sendTransaction(e) {
    return await this.requestCluster("sendTransaction", [e]);
  }
  async getTransaction(e) {
    return await this.requestCluster("getTransaction", [
      e,
      { encoding: "jsonParsed", commitment: "confirmed" }
    ]);
  }
  async watchTransaction(e, n) {
    return this.subscribeToCluster("signatureSubscribe", [e], n);
  }
  async getBalance(e, n = "sol") {
    const s = e != null ? e : S();
    if (!s)
      return null;
    const o = await this.requestCluster("getBalance", [s, { commitment: "processed" }]), r = n === "lamports" ? `${o.value} lamports` : `${o.value} sol`;
    return {
      value: new z(o.value),
      formatted: r,
      decimals: o.value,
      symbol: n
    };
  }
  async getFeeForMessage(e, n) {
    const r = (await this.constructTransaction(e, n)).compileMessage().serialize().toString("base64");
    return await this.requestCluster("getFeeForMessage", [r]);
  }
  async getProgramAccounts(e, n) {
    return (await this.requestCluster("getProgramAccounts", [
      e,
      { filters: n != null ? n : [], encoding: "jsonParsed", withContext: !0 }
    ])).value;
  }
  async getAllDomains(e) {
    return (await this.getProgramAccounts(Z.toBase58(), [
      {
        memcmp: {
          offset: 32,
          bytes: e
        }
      },
      {
        memcmp: {
          offset: 0,
          bytes: H.toBase58()
        }
      }
    ])).map(({ pubkey: s }) => s);
  }
  async getAccount(e, n = "base58") {
    const s = e != null ? e : S();
    if (!s)
      throw new Error("No address supplied and none connected");
    const o = await this.requestCluster("getAccountInfo", [
      s,
      {
        encoding: n
      }
    ]);
    if (!o)
      throw new Error("Invalid name account provided");
    const { value: r } = o;
    return r;
  }
  async performReverseLookup(e) {
    const n = I(e), s = await W(n, me), o = await this.getAccount(s.toBase58(), "base64");
    if (o) {
      const r = Buffer.from(o.data[0], "base64"), a = C.deserializeUnchecked(P.schema, P, r);
      a.data = r.slice(96);
      const i = new z(a.data.slice(0, 4), "le").toNumber();
      return `${a.data.slice(4, 4 + i).toString()}.sol`;
    }
    throw new Error(`Failed to perform reverse lookup on ${e}`);
  }
  async getSolDomainsFromPublicKey(e) {
    const n = await this.getAllDomains(e);
    return await Promise.all(
      n.map(async (o) => this.performReverseLookup(o))
    );
  }
  async getBlock(e) {
    return await this.requestCluster("getBlock", [e]);
  }
  async getAddressFromDomain(e) {
    const n = I(e.replace(".sol", "")), s = await W(n, void 0, H), o = await this.getAccount(s.toBase58(), "base64");
    return o ? C.deserializeUnchecked(
      P.schema,
      P,
      Buffer.from(o.data[0], "base64")
    ).owner.toBase58() : null;
  }
  async getFavoriteDomain(e) {
    const n = Buffer.from("favourite_domain"), s = new d(e).toBuffer(), [o] = await d.findProgramAddress(
      [n, s],
      le
    ), r = await this.getAccount(o.toBase58(), "base64");
    if (!r)
      return null;
    const a = C.deserialize(
      A.schema,
      A,
      Buffer.from(r.data[0], "base64")
    ), i = await this.performReverseLookup(a.nameAccount.toBase58());
    return { domain: a.nameAccount, reverse: i };
  }
  async request(e, n) {
    return (await this.getProvider()).request({ method: e, params: n });
  }
  async subscribeToCluster(e, n, s) {
    const o = await we(e, n, s);
    return () => {
      pe(o);
    };
  }
  async requestCluster(e, n) {
    const s = k(), { endpoint: o } = s;
    return (await fetch(o, {
      method: "post",
      body: JSON.stringify({
        method: e,
        params: n,
        jsonrpc: "2.0",
        id: q()
      }),
      headers: {
        "Content-Type": "application/json"
      }
    }).then(async (a) => {
      const i = await a.json();
      return console.log({ json: i }), i;
    }).catch((a) => {
      console.error(`Failed to fetch ${o}`, a);
    })).result;
  }
}
class x extends X {
  constructor(n) {
    super();
    l(this, "injectedWalletPath");
    if (!n)
      throw new Error("Invalid path provided, should match window..*");
    if (n.split(".")[0] !== "window")
      throw new Error("Injected wallet path must start at window");
    this.injectedWalletPath = n;
  }
  static connectorName(n) {
    return `injected-${n}`;
  }
  getConnectorName() {
    return x.connectorName(this.injectedWalletPath);
  }
  async disconnect() {
    const n = await this.getProvider();
    w(""), n.disconnect();
  }
  async getProvider() {
    const n = this.injectedWalletPath.split(".").slice(1);
    if (typeof window < "u") {
      const s = n.reduce((o, r) => o ? o[r] : null, window);
      if (s)
        return Promise.resolve(s);
    }
    return Promise.resolve(null);
  }
  isAvailable() {
    return Boolean(this.getProvider());
  }
  async connect() {
    const n = await (await this.getProvider()).connect();
    if (n != null && n.publicKey)
      return w(n.publicKey.toString()), n.publicKey.toString();
    if (n != null && n.publickey)
      return w(n.publickey.toString()), n.publickey.toString();
    if (n === !0) {
      const s = await this.getProvider(), o = s.pubkey || s.publicKey;
      return w(o.toString()), o;
    }
    throw new Error("Failed to connect");
  }
  async signMessage(n) {
    const s = new TextEncoder().encode(n), o = await this.request("signMessage", {
      message: s,
      format: "utf8"
    });
    if (!o)
      throw new Error(`Failed to sign message using ${this.getConnectorName()}`);
    const { signature: r } = o;
    return r;
  }
  async signTransaction(n, s) {
    const o = await this.constructTransaction(n, s), r = await (await this.getProvider()).signTransaction(o);
    if (r)
      return N.encode(r.serialize());
    throw new Error(`Could not sign transaction using ${this.getConnectorName()}`);
  }
  async signAndSendTransaction(n, s) {
    return this.sendTransaction(await this.signTransaction(n, s));
  }
}
const K = "window.phantom.solana";
class nn extends x {
  constructor() {
    super(K);
  }
  static connectorName() {
    return super.connectorName(K);
  }
}
const he = "error", u = class {
  static setSettings(e) {
    u.relayerRegion = e.relayerRegion, u.projectId = e.projectId, u.metadata = e.metadata;
  }
  static async getProvider() {
    if (u.provider || await u.init(), !u.provider)
      throw new Error("Failed to initialize universal provider");
    return u.provider;
  }
  static async init() {
    u.provider = await se.init({
      logger: he,
      relayUrl: u.relayerRegion,
      projectId: u.projectId,
      metadata: u.metadata
    }), u.provider.on(
      "session_ping",
      ({ id: e, topic: n }) => {
        console.log(e, n);
      }
    ), u.provider.on(
      "session_event",
      ({ event: e, chainId: n }) => {
        console.log(e, n);
      }
    ), u.provider.on(
      "session_update",
      ({ topic: e, params: n }) => {
        console.log(e, n);
      }
    ), u.provider.on("session_delete", () => {
      var e;
      (e = u.provider) == null || delete e.session.namespaces.solana, w("");
    });
  }
};
let g = u;
l(g, "provider"), l(g, "relayerRegion"), l(g, "projectId"), l(g, "metadata");
const R = class extends X {
  constructor({
    relayerRegion: n,
    metadata: s,
    qrcode: o,
    autoconnect: r
  }) {
    super();
    l(this, "provider");
    l(this, "qrcode");
    this.qrcode = Boolean(o), g.setSettings({
      projectId: J(),
      relayerRegion: n,
      metadata: s,
      qrcode: this.qrcode
    }), g.getProvider().then((a) => {
      a.on("session_delete", () => {
        delete a.session.namespaces.solana, w("");
      });
    }), r && g.getProvider().then((a) => {
      var i, c, f, y;
      if (console.log("Provider state", { provider: a }), (y = (f = (c = (i = a.session) == null ? void 0 : i.namespaces) == null ? void 0 : c.solana) == null ? void 0 : f.accounts) != null && y.length) {
        const [b] = a.session.namespaces.solana.accounts;
        console.log("Found accounts", b);
        const v = b.split(":")[2];
        w(v);
      }
    });
  }
  async disconnect() {
    var s, o;
    const n = await g.getProvider();
    try {
      await n.disconnect();
    } finally {
      (o = (s = n.session) == null ? void 0 : s.namespaces) == null || delete o.solana;
    }
    w("");
  }
  getConnectorName() {
    return R.connectorName;
  }
  isAvailable() {
    return !0;
  }
  async getProvider() {
    return await g.getProvider();
  }
  async signMessage(n) {
    const s = S();
    if (!s)
      throw new Error("No signer connected");
    const o = await this.request("solana_signMessage", {
      message: N.encode(new TextEncoder().encode(n)),
      pubkey: s
    }), { signature: r } = o;
    return r;
  }
  async signTransaction(n, s) {
    var c, f, y, b;
    const o = await this.constructTransaction(n, s);
    console.log("Made transaction", o);
    const r = {
      feePayer: (f = (c = o.feePayer) == null ? void 0 : c.toBase58()) != null ? f : "",
      instructions: o.instructions.map((v) => ({
        data: N.encode(v.data),
        keys: v.keys.map((j) => ({
          isWritable: j.isWritable,
          isSigner: j.isSigner,
          pubkey: j.pubkey.toBase58()
        })),
        programId: v.programId.toBase58()
      })),
      recentBlockhash: (y = o.recentBlockhash) != null ? y : ""
    };
    console.log("Formatted transaction", r);
    const a = await this.request("solana_signTransaction", r);
    o.addSignature(
      new d((b = S()) != null ? b : ""),
      Buffer.from(N.decode(a.signature))
    );
    const i = o.verifySignatures();
    if (!i)
      throw new Error("Signature invalid.");
    return console.log({ res: a, validSig: i }), N.encode(o.serialize());
  }
  async signAndSendTransaction(n, s) {
    return this.sendTransaction(await this.signTransaction(n, s));
  }
  async connect() {
    const n = k(), s = `solana:${n.id}`;
    console.log({ clusterId: s });
    const o = {
      solana: {
        chains: [s],
        methods: ["solana_signMessage", "solana_signTransaction"],
        events: [],
        rpcMap: {
          [s]: n.endpoint
        }
      }
    }, r = await g.getProvider();
    return console.log("thing2"), new Promise((a, i) => {
      r.on("display_uri", (c) => {
        this.qrcode ? te.open(c, (f) => {
          console.log("Opened QRCodeModal", f);
        }) : a(c);
      }), console.log("connecting.."), r.connect({
        pairingTopic: void 0,
        namespaces: o
      }).then((c) => {
        var y, b, v;
        if (!c)
          throw new Error("Failed connection.");
        const f = (v = (b = (y = c.namespaces) == null ? void 0 : y.solana) == null ? void 0 : b.accounts[0]) == null ? void 0 : v.split(":")[2];
        f ? (w(f), console.log({ rs: c }), a(f)) : i(new Error("Could not resolve address"));
      });
    });
  }
};
let T = R;
l(T, "connectorName", "walletconnect");
export {
  x as InjectedConnector,
  nn as PhantomConnector,
  T as WalletConnectConnector,
  Ee as connect,
  _e as devnet,
  Re as disconnect,
  Ze as fetchAddressFromDomain,
  Je as fetchName,
  Me as getAccount,
  qe as getAddress,
  De as getBalance,
  je as getConnectorIsAvailable,
  $e as getFeeForMessage,
  Le as getNetwork,
  J as getProjectId,
  Ue as getSolDomainsFromPublicKey,
  We as getTransaction,
  Ce as init,
  Qe as mainnetBeta,
  en as mainnetBetaBlockDaemon,
  Xe as mainnetBetaProjectSerum,
  Ve as mainnetBetaWalletConnect,
  He as sendTransaction,
  ie as setProjectId,
  Ke as signAndSendTransaction,
  Ie as signMessage,
  ze as signTransaction,
  Te as switchConnector,
  xe as switchNetwork,
  Ye as testnet,
  Fe as watchAddress,
  Oe as watchNetwork,
  Ge as watchTransaction
};
