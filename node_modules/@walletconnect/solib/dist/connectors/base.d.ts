import { PublicKey, Transaction } from '@solana/web3.js';
import BN from 'bn.js';
import type { AccountInfo, ClusterRequestMethods, ClusterSubscribeRequestMethods, FilterObject, RequestMethods, TransactionArgs, TransactionType } from '../types/requests';
import type { BlockResult } from '../types/block';
export interface Connector {
    isAvailable: () => boolean;
    getConnectorName: () => string;
    disconnect: () => Promise<void>;
    connect: () => Promise<string>;
    signMessage: (message: string) => Promise<string>;
    signTransaction: <Type extends TransactionType>(type: Type, params: TransactionArgs[Type]['params']) => Promise<string>;
    sendTransaction: (encodedTransaction: string) => Promise<string>;
    getAccount: (requestedAddress?: string, encoding?: 'base58' | 'base64' | 'jsonParsed') => Promise<AccountInfo | null>;
    signAndSendTransaction: <Type extends TransactionType>(type: Type, params: TransactionArgs[Type]['params']) => Promise<string>;
    getBalance: (requestedAddress?: string) => Promise<{
        formatted: string;
        value: BN;
        decimals: number;
        symbol: string;
    } | null>;
    getTransaction: (transactionSignature: string) => Promise<ClusterRequestMethods['getTransaction']['returns']>;
    watchTransaction: (transactionSignature: string, callback: (params: unknown) => void) => Promise<() => void>;
    getSolDomainsFromPublicKey: (address: string) => Promise<string[]>;
    getAddressFromDomain: (address: string) => Promise<string | null>;
    getFavoriteDomain: (address: string) => Promise<{
        domain: PublicKey;
        reverse: string;
    } | null>;
    getBlock: (slot: number) => Promise<BlockResult | null>;
    getFeeForMessage: <Type extends TransactionType>(type: Type, params: TransactionArgs[Type]['params']) => Promise<number>;
}
export declare class BaseConnector {
    getConnectorName(): string;
    protected getProvider(): Promise<{
        request: (args: any) => any;
    }>;
    protected constructTransaction<TransType extends keyof TransactionArgs>(type: TransType, params: TransactionArgs[TransType]['params']): Promise<Transaction>;
    sendTransaction(encodedTransaction: string): Promise<string>;
    getTransaction(transactionSignature: string): Promise<import("..").TransactionResult | null>;
    watchTransaction(transactionSignature: string, callback: (params: Transaction) => void): Promise<() => void>;
    getBalance(requestedAddress?: string, currency?: 'lamports' | 'sol'): Promise<{
        value: BN;
        formatted: string;
        decimals: number;
        symbol: "lamports" | "sol";
    } | null>;
    getFeeForMessage<TransType extends keyof TransactionArgs>(type: TransType, params: TransactionArgs[TransType]['params']): Promise<number>;
    getProgramAccounts(requestedAddress: string, filters?: FilterObject[]): Promise<{
        account: AccountInfo;
    }[]>;
    getAllDomains(address: string): Promise<any[]>;
    getAccount(nameAccountKey?: string, encoding?: 'base58' | 'base64' | 'jsonParsed'): Promise<AccountInfo | null>;
    performReverseLookup(address: string): Promise<string>;
    getSolDomainsFromPublicKey(address: string): Promise<string[]>;
    getBlock(slot: number): Promise<BlockResult | null>;
    getAddressFromDomain(domain: string): Promise<string | null>;
    getFavoriteDomain(address: string): Promise<{
        domain: PublicKey;
        reverse: string;
    } | null>;
    request<Method extends keyof RequestMethods>(method: Method, params: RequestMethods[Method]['params']): Promise<RequestMethods[Method]['returns']>;
    subscribeToCluster<Method extends keyof ClusterSubscribeRequestMethods>(method: Method, params: ClusterSubscribeRequestMethods[Method]['params'], callback: (params: ClusterSubscribeRequestMethods[Method]['returns']) => void): Promise<() => void>;
    requestCluster<Method extends keyof ClusterRequestMethods>(method: Method, params: ClusterRequestMethods[Method]['params']): Promise<ClusterRequestMethods[Method]['returns']>;
}
